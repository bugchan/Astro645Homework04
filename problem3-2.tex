\section{Off the grid...}

A form of interpolation on an irregular grid is Radial Basis Interpolation (RBF). It uses the idea that data points are only influence by \\
nearby points by using functional forms that are a function of the distance from each point. 

Some radial basis functions are:
\begin{align}
\mathrm{Multiquadric:}\; &\phi(r)= (r^2 + r_0^2)^{1/2} \\
\mathrm{Inverse:}\;&\phi(r)= (r^2 + r_0^2)^{-1/2} \\
\mathrm{Thin-plate:}\;&\phi(r)= r^2 \log\left(\frac{r}{r_0}\right) \\
\mathrm{Gaussian:}\;&\phi(r) = \exp\left(-\frac{1}{2}\frac{r^2}{r^2_0}\right)\\
\mathrm{Cubic:}\; &\phi(r)=r^3
\end{align}

where $r_0$ is a free parameter. To choose this parameter it is recommended to experiment with several values. 

In this exercise, given an image showed in Figure \ref{fig:p2Orig}, here after refer as the original image, we needed to removed 25\%, 50\% and 75\% of pixels. To achieve this, I first determined the number of pixels needed to removed for the ratio of pixels removed and total pixels correspond to the percentages given. Then I created an array of uniformly random coordinates of that length. Since some of the random coordinate repeated, the code starts to remove pixels until it reaches the desired percentage.

\begin{figure}
    \centering
    \includegraphics{CodeAndFigures/hw04p2Original.png}
    \caption{Original image}
    \label{fig:p2Orig}
\end{figure}

After removing the desired percentage of pixels, I created the base images for interpolating with different radial functions. The 3 radial basis functions selected were quadratic, inverse and thin plate. 

After this, the code determines the best r0 for each case. The range of r0 to be evaluated was determined by a manual process of creating a coarse grid of r0 values ranging from .1 to 15 and plotting them. After viewing the plots, I determined that the best fit was within .1 and 1.5 for all of my functions. Then, this range is used to find the best r0 in a finer grid.

To determine the best fit, it compared the RMS of the square difference between the reconstructed image $I_r$ and original image $I_0$ by:
\begin{equation}
    \mathrm{error}_\mathrm{RMS}=\sqrt{\frac{\sum(I_0 - I_r)^2}{N}}
\end{equation}
where $N$ is the total number of pixels in the original image. 
Figure\ref{fig:p2Error} shows three plots for each base image. Each plot shows how the RMS changes depending of the value of r0. Note that for the thin plate case, the RMS is constant since the implementation of this radial function on scipy does not depend of r0.  
\begin{figure*}
    \centering
    \includegraphics{CodeAndFigures/hw04p2ErrorPlot.png}
    \caption{Plot that showed the RMS values  }
    \label{fig:p2Error}
\end{figure*}

After determining the best r0, it selects the corresponding reconstructed image and plots it. \\
Figure \ref{fig:p2InterAll} shows the base image and the reconstructed image with the lowest RMS for each case. From this comparison we can note that the best interpolation for all base images is achieved by using the multiquadric function. 

\begin{figure*}
    \centering
    \includegraphics{CodeAndFigures/hw04p2InterpolatedAll.png}
    \caption{Base Image and the best reconstructed image with the lowest RMS. It shows the corresponding error RMS achieved for each case and the optimal r0 for the multiquadric and inverse radial functions.}
    \label{fig:p2InterAll}
\end{figure*}